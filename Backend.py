# -*- coding: utf-8 -*-
"""Any pdf AI with UI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11AXwIhvsVtqax022StpYW-7TvRqsc4DL
"""

from llama_index.embeddings.gemini import GeminiEmbedding
from llama_index.vector_stores.chroma import ChromaVectorStore
from llama_index.core import SimpleDirectoryReader, VectorStoreIndex
from llama_index.core.memory import ChatMemoryBuffer
from llama_index.core.storage.storage_context import StorageContext
from llama_index.core import Settings
from llama_index.llms.gemini import Gemini
from llama_cloud import MessageRole

import PyPDF2
import chromadb

import google.generativeai as genai
import warnings
import os

# Set up your Google API credentials
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "/content/organic-dryad-434803-u3-4b45fed68b4b.json"
warnings.filterwarnings("ignore")

# Set up Google Generative AI API key
genai.configure(api_key='AIzaSyDFqHznL-EB9_CHIGFrwVfwmUBCmk4nRzc')

from llama_index.core.node_parser import SentenceSplitter

Settings.llm = Gemini(models='gemini-pro', api_key='AIzaSyDFqHznL-EB9_CHIGFrwVfwmUBCmk4nRzc')
Settings.embed_model = GeminiEmbedding(model_name="models/embedding-001", api_key='AIzaSyDFqHznL-EB9_CHIGFrwVfwmUBCmk4nRzc')
Settings.node_parser = SentenceSplitter(chunk_size=512, chunk_overlap=20)
Settings.num_output = 512
Settings.context_window = 3900



from llama_index.core import Document

class QAChatbot:
    def __init__(self, document_path):
        self._chroma_client = chromadb.EphemeralClient()
        self._llm = Settings.llm
        self._document_path = document_path
        self._index = None
        self._create_kb()
        self._create_chat_engine()

    def _create_kb(self):
        try:
            # Check if the document is a PDF or TXT
            if self._document_path.endswith('.txt'):
                print("Reading TXT file")
                reader = SimpleDirectoryReader(input_files=[self._document_path])
                documents = reader.load_data()
                print("Documents loaded successfully from TXT file")
            elif self._document_path.endswith('.pdf'):
                documents = self._load_pdf(self._document_path)
                print("Documents loaded successfully from PDF file")
            else:
                raise ValueError("Unsupported file format. Please provide a .txt or .pdf file.")

            # Check if the collection already exists and delete it
            collection_name = "collection"
            existing_collections = [col.name for col in self._chroma_client.list_collections()]

            if collection_name in existing_collections:
                self._chroma_client.delete_collection(collection_name)  # Delete the whole collection
                print(f"Deleted existing collection: {collection_name}")

            # Create a new collection
            chroma_collection = self._chroma_client.create_collection(collection_name)
            print(f"Created new collection: {collection_name}")

            vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
            storage_context = StorageContext.from_defaults(vector_store=vector_store)

            # Create the vector index with documents and embeddings
            self._index = VectorStoreIndex.from_documents(documents, storage_context=storage_context, embed_model=Settings.embed_model)
            print("Knowledgebase created successfully!")
        except Exception as e:
            print(f"Error while creating knowledgebase: {e}")
            self._index = None


    def _load_pdf(self, pdf_path):
        # Extract text from PDF
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                text = ""
                for page in pdf_reader.pages:
                    text += page.extract_text()

            # Wrap the extracted text into Document objects
            documents = [Document(text=text)]  # Create a list of Document objects
            return documents
        except Exception as e:
            print(f"Error loading PDF: {e}")
            return []

    def _create_chat_engine(self):
        if self._index is None:
            print("Knowledgebase is not created. Cannot create chat engine.")
            return
        memory = ChatMemoryBuffer.from_defaults(token_limit=150000)
        self._chat_engine = self._index.as_chat_engine(
            chat_mode="context",
            memory=memory,
            system_prompt=self._prompt,
            llm=self._llm,
           
        )

    def interact_with_llm(self, user_query):
        try:
            if self._chat_engine is None:
                print("Chat engine is not initialized due to knowledgebase creation failure.")
                return "Sorry, the chat engine is not available."

            print("Debug: Sending query to chat engine")
            AgentChatResponse = self._chat_engine.chat(user_query)
            print("Debug: Received response from chat engine")
            
            # Extract the generated answer
            answer = AgentChatResponse.response

            # Extract retrieved document segments (accessing node and then its content)
            retrieved_segments = [node.node.text for node in AgentChatResponse.source_nodes]

            # Return both the answer and the retrieved document segments
            return answer, retrieved_segments
        
        except KeyError as e:
            print(f"KeyError: {e}")
            return "An error occurred while processing your query.", []

    @property
    def _prompt(self):
        return """
            You are a professional AI assistant that answers questions based on the provided document.
            Use relevant information from the document to answer any questions accurately and concisely.

            if answer is not available in document, try to answer on the base of previous conversation,if u know the answer properly.

            If the information is not available in document and in previous conversation, simply state that the answer is not in the document.
        """

